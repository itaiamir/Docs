{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 Calibri;\f2\fnil\fcharset0 LucidaGrande;
}
{\colortbl;\red255\green255\blue255;\red0\green77\blue187;\red155\green0\blue211;\red75\green172\blue198;
\red0\green0\blue255;\red0\green186\blue251;\red71\green204\blue252;\red102\green177\blue50;\red255\green0\blue0;
\red0\green255\blue0;\red198\green50\blue253;\red160\green114\blue253;\red114\green44\blue253;\red0\green145\blue206;
\red74\green0\blue230;\red85\green142\blue40;\red174\green0\blue240;}
\paperw11900\paperh16840\vieww20180\viewh25860\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 \ul \ulc0 I
\f1\b\fs36 IOS7 Core\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\i\fs22 \cf2 \ulnone \

\i0\fs28 \cf3 Changing The display contrast of the status bar\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b0\fs22 \cf0 in a View controller:\
-(
\b \cf4 UIStatusBarStyle
\b0 \cf0 ) preferredStatusBarStyle\
\{\
   
\b \cf3 return 
\b0 \cf0 UIStatusBarStyleLightContent;\
\}\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b\fs28 \cf3 Creating content subview to avoid status bar
\b0\fs22 \cf0 \
\pard\pardeftab720\partightenfactor0
\cf0 In ViewController.h\

\b \cf5 @property
\b0 \cf0  (
\b \cf5 strong, nonatomic
\b0 \cf0 ) 
\b \cf6 UIView
\b0 \cf0  *contentSubview;\
\
In ViewController.m\
-(
\b \cf5 void
\b0 \cf0 ) loadView\
\{\
    
\b \cf6 UIView
\b0 \cf0  *
\b view
\b0  = [[
\b \cf6 UIView alloc
\b0 \cf0 ] 
\b \cf6 init
\b0 \cf0 ];\
    
\b view
\b0 .
\b \cf6 backgroundColor
\b0 \cf0  = [
\b \cf6 UIColor greenColor
\b0 \cf0 ];\
\
    
\b \cf5 self
\b0 \cf0 .
\b \cf6 contentSubview
\b0 \cf0  = [[
\b \cf6 UIView alloc
\b0 \cf0 ] 
\b \cf6 init
\b0 \cf0 ];\
    
\b \cf5 self
\b0 \cf0 .
\b \cf6 contentSubview
\b0 \cf0 .
\b \cf6 backgroundColor
\b0 \cf0  = [
\b \cf6 UIColor orangeColor
\b0 \cf0 ];\
    [view 
\b \cf6 addSubview
\b0 \cf0 :
\b \cf5 self
\b0 \cf0 .
\b \cf6 contentSubview
\b0 \cf0 ];\
\
    
\b \cf5 self
\b0 \cf0 .
\b \cf6 view
\b0 \cf0  = 
\b view
\b0 ;\
\}
\b \
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b0 \cf0 \
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 Use the new topLayoutGuide property
\b0 \
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 topLayoutGuide
\b0 \cf0  is a new UIViewController property that allows you to get the size\
of the status bar area to account for it in your view layout.\
\
if 
\b no
\b0  status bar:\

\b \cf5 self
\b0 \cf0 .
\b \cf6 topLayoutGuide.length
\b0 \cf0  == 0\
\
if 
\b there is
\b0  a status bar:\

\b \cf5 self
\b0 \cf0 .
\b \cf6 topLayoutGuide.length
\b0 \cf0  == 20\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 Moving contentSubview below the status bar area
\b0 \
\pard\pardeftab720\partightenfactor0
\cf0 In ViewController.m\
\pard\pardeftab720\sl276\slmult1\partightenfactor0
\cf0 - (
\b \cf5 void
\b0 \cf0 ) viewWillLayoutSubviews\
\{\
     [
\b \cf5 super
\b0 \cf0  
\b \cf6 viewWillLayoutSubviews
\b0 \cf0 ];\
\
     
\b \cf5 self
\b0 \cf0 .
\b \cf6 contentSubview.frame
\b0 \cf0  = 
\b \cf6 CGRectMake
\b0 \cf0 (0,\
					          
\b \cf5 self
\b0 \cf0 .
\b \cf6 topLayoutGuide.length
\b0 \cf0 , \
					          
\b \cf6 CGRectGetWidth
\b0 \cf0 (
\b \cf5 self
\b0 \cf0 .
\b \cf6 view.frame
\b0 \cf0 ),\
                                                                                  
\b \cf6 CGRectGetHeight
\b0 \cf0 (
\b \cf5 self
\b0 \cf0 .
\b \cf6 view.frame
\b0 \cf0 )\
					          - 
\b \cf5 self
\b0 \cf0 .
\b \cf6 topLayoutGuide.length \
					          - \cf5 self\cf6 .bottomLayoutGuide.length
\b0 \cf0 );\
\
\}\
It is preferred to set them here instead of 
\b viewDidLoad
\b0  \
because the topLayoutGuide isn\'92t set until right before 
\b viewWillLayoutSubviews
\b0  is called\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 Layout the rest of the subviews
\b0 \
The rest of the labels can now be added as subviews of contentSubview\
without fear of interfering with the status bar area.\
\
Use the contentSubview frame as a top reference for subviews instead of topLayoutGuide.\
\
In ViewController.m\
-(
\b \cf5 void
\b0 \cf0 ) loadView\
\{\
	
\b \cf5 self
\b0 \cf0 .wonLabel = [[
\b \cf6 UILabel alloc\cf0 ]\cf6  init
\b0 \cf0 ];\
               [
\b \cf5 self
\b0 \cf0 .
\b \cf6 contentSubview
\b0 \cf0  
\b \cf6 addSubview
\b0 \cf0 :
\b \cf5 self
\b0 \cf0 .wonLabel\
\}\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b\fs28 \cf3 Navigation And Tab Bars
\b0\fs22 \cf0 \
Nav bar takes up additional space\
The status bar and nav bar are attached so now :\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 topLayoutGuide.length
\b0 \cf0  == 64\
\
If your main view or content subview is a scroll view, there\'92s a few things to understand :\
A \'93padding\'94 is added for you when wither self.view or the immediate content subview of self.view is a UIScrollView\
The padding amount is equal to:\

\b \cf5 self
\b0 \cf0 .
\b \cf6 topLayoutGuide.length
\b0 \cf0 \
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 This property turns on the padding  ( will take care of the tab bar also ):
\b0 \
-(
\b \cf5 void
\b0 \cf0 ) loadView\
\{\
	
\b \cf5 self
\b0 \cf0 .
\b \cf6 automaticallyAdjustsScrollViewInsets
\b0 \cf0  = 
\b \cf5 YES
\b0 \cf0 ;\
\}\
\
For Tab Bars we have this property :\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 bottomLayoutGuide
\b0 \cf0 .
\b \cf6 length
\b0 \cf0  == 49\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\f2\b\fs28 \cf3 tintColor
\f1\b0\fs22 \cf0 \
tintColor is an easy way to set key color for all your major UIKit subviews in one place.\
\
AppDelegate.m\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 window
\b0 \cf0 .
\b \cf6 tintColor
\b0 \cf0  = [
\b \cf6 UIColor
\b0 \cf0  
\b \cf6 redColor
\b0 \cf0 ];\
\
tintColor 
\b cascades
\b0  down to children when it is set in parent.\
The tintColor cascade can be 
\b overridden
\b0  by child views\
\
Controller1.m\

\b \cf5 self
\b0 \cf0 .
\b \cf7 view
\b0 \cf0 .
\b \cf6 tintColor
\b0 \cf0  = [
\b \cf6 UIColor greenColor
\b0 \cf0 ];\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\f2\b\fs28 \cf3 Nav bar customization
\f1\b0\fs22 \cf0 \
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 UIBarStyleDefault
\b0 \cf0  - 
\b white
\b0  background, 
\b black
\b0  status bar text, 
\b black
\b0  nav item text.\

\b \cf5 UIBarStyleBlack
\b0 \cf0  - 
\b black
\b0  background, 
\b white
\b0  status bar text, 
\b white
\b0  nav item text.\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 AppDelegate.m
\b0 \
-(
\b \cf5 BOOL
\b0 \cf0 ) application:(
\b \cf6 UIApplication
\b0 \cf0  *) application\
didFinishLaunchingWithOptions:(
\b \cf6 NSDictionary
\b0 \cf0  *) launchOptions\
\{\
	
\b \cf6 UINavigationController
\b0 \cf0  *navController = \'85.\
	navController.
\b \cf6 navigationBar
\b0 \cf0 .
\b barStyle
\b0  = 
\b \cf6 UIBarStyleDefault
\b0 \cf0 ;  
\b \cf8 //default style.
\b0 \cf0 \
	
\b \cf5 self
\b0 \cf0 .
\b \cf6 window
\b0 \cf0 .
\b \cf6 rootViewController
\b0 \cf0  = navController;\
\}\
\

\b The difference between tintColor and barTintColor
\b0 \
\

\b AppDelegate.m
\b0 \
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 window
\b0 \cf0 .
\b tinColor
\b0  = [
\b \cf6 UIColor redColor
\b0 \cf0 ];\

\b \cf5 self
\b0 \cf0 .
\b \cf6 navigationController
\b0 \cf0 .
\b \cf6 navigationBar
\b0 \cf0 .
\b tintColor
\b0  = [
\b \cf6 UIColor greenColor
\b0 \cf0 ];\

\b \cf5 self
\b0 \cf0 .
\b \cf6 navigationController
\b0 \cf0 .
\b \cf6 navigationBar
\b0 \cf0 .
\b barTintColor
\b0  = [
\b \cf6 UIColor blueColor
\b0 \cf0 ];\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 barTintColor
\b0  -  The color of the bar itself\

\b tintColor
\b0  - tint color of the items in the bar\
\
Both for your UINavigationBar, UIToolbar or UITabBar\
\

\b Controlling bar images with rendering modes
\b0 \
\

\b ViewController1.m
\b0 \

\b \cf6 UIImage
\b0 \cf0  *
\b barImage
\b0  = [
\b \cf6 UIImage imageNamed
\b0 \cf0 :
\b \cf5 @\'93ios_icon\'94
\b0 \cf0 ];\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 tabBarItem
\b0 \cf0 .
\b \cf6 image
\b0 \cf0  = [barImage 
\b \cf6 imageWithRenderingMode\cf0 :UIImageRenderingModeAlwaysTemplate
\b0 ];\
\
The template color comes from tintColor\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 AlwaysTemplate
\b0  - The tint will fill the image.\

\b AlwaysOriginal
\b0  - The Image without tint.\
\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\f2\b\fs28 \cf3 Fonts And Font Descriptors
\f1\b0\fs22 \cf0 \
To create a Font in iOS :\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf6 UIFont
\b0 \cf0  *font = [
\b \cf6 UIFont fontWithName
\b0 \cf0 :
\b \cf5 @\'93HelveticaNeue-Italic\'94
\b0 \cf0  
\b \cf6 size
\b0 \cf0 :18];\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf9 Problem: Fonts names don\'92t always follow a consistent format
\b0 \cf0 \
\

\b \cf10 Solution:
\b0 \cf0  Describe the font you want instead of explicitly naming it\
	   Attributes - Family, Face, Size\
 	   Traits - Bold, Italic, Condensed\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf6 UIFontDescriptor
\b0 \cf0  *
\b \cf11 baseFont
\b0 \cf0  = [
\b \cf6 UIFontDescriptor
\b0 \cf0  
\b fontDescriptorWithFontAttributes
\b0 :\
			            
\b \cf5 @
\b0 \cf0 \{
\b \cf6 UIFontDescriptorFamilyAttribute
\b0 \cf0 :
\b \cf5 @\'93Helvetica Neue\'94
\b0 \cf0 \}];\
\

\b this is just the base font if i want it italic: 
\b0 \

\b \cf6 UIFontDescriptor
\b0 \cf0  *
\b \cf12 italicBase
\b0 \cf0  = [
\b \cf11 baseFont
\b0 \cf0  
\b \cf6 fontDescriptorWithSymbolicTraits
\b0 \cf0 :
\b UIFontDescriptorTraitItalic
\b0 ];\
\

\b and finally when i create my font call fontWithDescriptor :
\b0 \

\b \cf6 UIFont
\b0 \cf0  *font = [
\b \cf6 UIFont
\b0 \cf0  
\b fontWithDescriptor
\b0 :
\b \cf12 italicBase
\b0 \cf0  
\b \cf6 size
\b0 \cf0 :18];\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 \ul Resizing UILabels based on updated text
\b0 \ulnone \
if we have an UILabel and the text returned from a server is too long we need to make sure the Label will have room :\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf6 CGSize
\b0 \cf0  
\b \cf13 labelSize
\b0 \cf0  = [
\b \cf5 self
\b0 \cf0 .
\b \cf6 label
\b0 \cf0 .
\b \cf6 text
\b0 \cf0  
\b sizeWithAttributes
\b0 : 
\b \cf5 @
\b0 \cf0 \{
\b \cf6 NSFontAttributeName
\b0 \cf0 : 
\b \cf5 self
\b0 \cf0 .
\b \cf6 label
\b0 \cf0 .
\b \cf6 font
\b0 \cf0 ,\
						
\b UIFontDescriptorTraitsAttribute
\b0 :
\b \cf5 @
\b0 \cf0 (
\b \cf6 UIFontDescriptorTraitsBold
\b0 \cf0 )\};\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 label
\b0 \cf0 .
\b \cf6 frame
\b0 \cf0  = 
\b \cf6 CGRectMake
\b0 \cf0 (0, 0, 
\b \cf13 labelSize
\b0 \cf0 .width, 
\b \cf13 labelSize
\b0 \cf0 .height);\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 \ul Font attributes and NSAttributedString attributes
\b0 \ulnone \
The properties of displayed text can come from a combination of font attributes and NSAttributedString attributes.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\b \cf5 Font attributes
\b0 \cf0 		
\b \cf5 NSAttributedString attributes
\b0 \cf0 \
Name			Paragraph Style\
Family 			Kerning and ligatures\
Face			Underline and strikethrough\
Size			Writing Direction\
Traits			Text Effects (Letterpress)\
\

\b Attributed String refresher
\b0 \
-(
\b \cf5 void
\b0 \cf0 ) viewDidLoad\
\{\
	
\b \cf6 NSMutableAttributedString
\b0 \cf0  *
\b text
\b0  = [[
\b \cf6 NSMutableAttributedString alloc
\b0 \cf0 ] 
\b \cf6 initWithString
\b0 \cf0 :
\b \cf5 @\'93Hello\'94
\b0 \cf0 ];\
	[
\b text
\b0  
\b \cf6 andAttributes
\b0 \cf0 :
\b \cf5 @
\b0 \cf0 \{
\b NSTextEffectAttributeName
\b0 : 
\b \cf6 NSTextEffectLetterpressStyle
\b0 \cf0 ,\
			            
\b NSForegroundColorAttributedName
\b0 : [
\b \cf6 UIColor grayColor
\b0 \cf0 ],\
			            
\b NSKernAttributeName
\b0 : 
\b \cf5 @2.0
\b0 \cf0 \}\
                                      
\b \cf6 range
\b0 \cf0 :
\b NSMakeRange
\b0 (0, 
\b text
\b0 .length)];\
\
	
\b \cf5 self
\b0 \cf0 .
\b \cf6 label
\b0 \cf0 .
\b attributedText
\b0  = 
\b text
\b0 ;	\
\}\
\pard\pardeftab720\sl276\slmult1\partightenfactor0
\cf0 \
So now to resize a label with font attributes and attributed strings:\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf6 CGSize
\b0 \cf0  
\b \cf13 labelSize
\b0 \cf0  = [
\b \cf5 self
\b0 \cf0 .
\b \cf6 label
\b0 \cf0 .
\b \cf6 text
\b0 \cf0  
\b sizeWithAttributes
\b0 : 
\b \cf5 @
\b0 \cf0 \{
\b \cf6 NSFontAttributeName
\b0 \cf0 : 
\b \cf5 self
\b0 \cf0 .
\b \cf6 label
\b0 \cf0 .
\b \cf6 font
\b0 \cf0 ,\
		        
\b UIFontDescriptorTraitsAttribute
\b0 :
\b \cf5 @
\b0 \cf0 (
\b \cf6 UIFontDescriptorTraitsBold
\b0 \cf0 )\
           			           
\b NSKernAttributeName
\b0 :
\b \cf5 @
\b0 \cf0 2.0\};\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 label
\b0 \cf0 .
\b \cf6 frame
\b0 \cf0  = 
\b \cf6 CGRectMake
\b0 \cf0 (0, 0, 
\b \cf13 labelSize
\b0 \cf0 .width, 
\b \cf13 labelSize
\b0 \cf0 .height);\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf9 Anything that changes the way the text renders will affect the frame size.
\b0 \cf0 \
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\f2\b\fs28 \cf3 Sizing Text View
\f1\b0\fs22 \cf0 \
If we have a text view and we get a long text from the network.\
and we want to fit it in the text view WITHOUT scrolling:\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 Text Kit Classes
\b0 \
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 UITextView
\b0 \cf0  -              Displays text in a UIScrollView\

\b \cf5 NSTextContainer
\b0 \cf0  -    Determines where text can laid out and provides the frame information for the text view.\

\b \cf5 NSLayoutManager
\b0 \cf0  - Manages communication between the text storage and text container.\

\b \cf5 NSTextStorage
\b0 \cf0  -        An NSMutableAttributedString that stores the text view string.\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 Layers of the textView
\b0 \

\b \cf14 textView
\b0 \cf0 .
\b \cf15 frame
\b0 \cf0  - The area of all the UITextView (not the frame of the text) with padding around the edges\

\b \cf14 textView
\b0 \cf0 .
\b \cf15 textContainerInset
\b0 \cf0  - Is the padding area. \
			           top (default is 8), bottom (default is 8), (left is 0), (right is 0).\

\b \cf14 textView
\b0 \cf0 .
\b \cf15 textContainer
\b0 \cf0  - The actual text container this is the frame of
\b  just the Text
\b0 .\

\b \cf14 textView
\b0 \cf0 .
\b \cf15 textContainer
\b0 \cf0 .
\b lineFragmentPadding
\b0  - The padding before each line (default is 5).\
\

\b Resizing a UITextView with Text Kit
\b0 \
What we really need is the CGRect containing the text,\
not the CGRect frame of the UITextView\
\

\b \cf16 //textView text updated from network response\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b0 \cf0 make sure the textContainer is ready for measuring\
[
\b \cf5 self
\b0 \cf0 .
\b \cf14 textView
\b0 \cf0 .
\b layoutManage
\b0 r 
\b \cf6 ensureLayoutForTextContainer
\b0 \cf0 :
\b \cf5 self
\b0 \cf0 .
\b \cf14 textView
\b0 \cf0 .
\b textContainer
\b0 ];\
\
return the frame used to draw the text container size\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf6 CGRect
\b0 \cf0  textContainerRect = [
\b \cf5 self
\b0 \cf0 .
\b \cf6 textView
\b0 \cf0 .
\b layoutManager
\b0  
\b \cf6 usedRectForTextContainer
\b0 \cf0 :
\b \cf5 self
\b0 \cf0 .
\b \cf6 textView
\b0 \cf0 .
\b textContainer
\b0 ]\
\

\b So where we perform this sizing ?
\b0 \
Well unlike before where we\'92ve been resizing everything in 
\b viewWillLayoutSubviews
\b0 ,\
you actually need to resize textViews inside of 
\b ViewDidLayoutSubviews
\b0 .\
Because some of the math that creates the size inside of the text container is not performed until after\
the ViewWillLayoutSubviews method runs.\
\

\b Using the textContainerInsets in the height calculation
\b0 \
We need to account for the 
\b textContainerInsets
\b0  when setting the height\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf5 self
\b0 \cf0 .
\b \cf6 textView
\b0 \cf0 .
\b frame
\b0  = 
\b \cf6 CGRectMake
\b0 \cf0 (0, 0, 
\b textContainerRect
\b0 .
\b \cf6 size
\b0 \cf0 .
\b \cf6 width
\b0 \cf0 ,\
			            
\b \cf17 ceilf
\b0 \cf0  (
\b textContainerRect
\b0 .
\b \cf6 size\cf0 .\cf6 height
\b0 \cf0  +\
				       
\b \cf5 self
\b0 \cf0 .
\b \cf6 textView
\b0 \cf0 .
\b textContainerInset
\b0 .
\b \cf6 top 
\b0 \cf0 +\
				       
\b \cf5 self
\b0 \cf0 .
\b \cf6 textView
\b0 \cf0 .
\b textContainerInset
\b0 .
\b \cf6 bottom
\b0 \cf0 ));\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf17 ceilf
\b0 \cf0  - Round up to avoid pixel rounding errors\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\f2\b\fs28 \cf3 Dynamic Type
\f1\b0\fs22 \cf0 \
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 Use Text Styles When You Want Dynamic Type
\b0 \
Pre-defined fonts that can scale based on user input.\
Declared with semantic font descriptors\
\
UIFontTextStyleHeadline\
UIFontTextStyleSubheadline\
UIFontTextStyleBody\
UIFontTextStyleCaption1\
UIFontTextStyleCaption2\
UIFontTextStyleFootnote\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf10 Pros - User can choose text size
\b0 \cf0 \

\b \cf9 Cons - MUST USE APPLE\'92S FONT
\b0 \cf0 \
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 {{\NeXTGraphic Pasted Graphic 1.tiff \width7720 \height3440
}¬}\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\fs22 \cf0 \
\pard\pardeftab720\sl276\slmult1\partightenfactor0
\cf0 \
You can apply text styles to some text but not to others ( you can mix ).\
\
\pard\pardeftab720\sl276\slmult1\partightenfactor0

\b \cf0 Assign Text Styles With Preferred font descriptors
\b0 \
UIFontDescriptor *body = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFont\
\
\
\
\
\
\
\
\
\
\
\
}